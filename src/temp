import csv
from random import choice, shuffle


def parser(filePath):
    sudoku_instances = []
    with open(filePath, 'r') as file:
        csv_reader = csv.reader(file, delimiter=';')

        for row in csv_reader:
            instance = {'id': row[0],
                        'difficulty': row[1],
                        'puzzle': row[2]}
            if len(row) == 4:
                instance['solution'] = row[3]

            sudoku_instances.append(instance)
    sudoku_instances.pop(0)
    return sudoku_instances



class SudokuCSP:

    # j : column number, i : row number, v : value that we want to check if exist
    row_constraint = lambda j, i, v, board: False if v in board[j][:] else True
    column_constraint = lambda j, i, v, board: False if v in board[:][i] else True
    square_constraint = lambda j, i, v, board: False if v in board[int(j / 3) * 3: int(j / 3) * 3 + 3][
                                                             int(i / 3) * 3: int(i / 3) * 3 + 3] else True
    constraints = [row_constraint, column_constraint, square_constraint]

    def __init__(self, puzzlePlain = None):
        self.domains = [[[1,2,3,4,5,6,7,8,9] for x in range(9)] for y in range(9)]

        if puzzlePlain != None:
            board = SudokuCSP.parsePuzzle(puzzlePlain)

            for j in range(9):
                for i in range(9):
                    if board[j][i] !=0:
                        self.domains[j][i] = [board[j][i]]


    def backtracingSearchStart(self):
        board = [[0 for x in range(9)] for y in range(9)]
        domains = self.domains[:]
        solutions = []

        self.backtraceingSearch(board, solutions, stepsNumber=0)
        print("amount of solutions: " + str(len(solutions)))
        SudokuCSP.printBoard(solutions[0])


    def backtraceingSearch(self, board,domains, solutions, stepsNumber):
        j, i = self.pickVarWithSmallestDomain(board)


        for elem in self.pickValRandom(self.domains[j][i]):
            if self.checkConstraints(j, i, elem, board):
                tempBoard = board[:]
                tempBoard[j][i] = elem
                #debug
                print("-----------STEP----------")
                print("Step: %d, j: %d, i: %d" % (stepsNumber, j, i))
                print("domain: " + str(self.domains[j][i]))
                SudokuCSP.printBoard(tempBoard)
                #debug
                if stepsNumber < 80:
                    self.backtraceingSearch(board, solutions, stepsNumber + 1)
                if stepsNumber >= 80:
                    tempBoard[j][i] = elem
                    solutions.append(tempBoard)
                    return
        return

    def pickVarWithSmallestDomain(self, board):
        bestL = 10
        bJ, bI = 0, 0
        for j in range(9):
            for i in range(9):
                if len(self.domains[j][i]) < bestL and board[j][i] == 0:
                    bestL = len(self.domains[j][i])
                    bJ, bI = j, i
        return bJ, bI

    def pickValRandom(self, domain):
        tmp = domain[:]
        shuffle(tmp)
        return tmp

    def pickValInOrder(self, domain):
        return domain[:]

    def checkConstraints(self, column, row, value, board):
        for constraint in self.constraints:
            if constraint(column, row, value, board) == False:
                return False
        return True

    @staticmethod
    def parsePuzzle(puzzlePlain):
        board = [[0 for x in range(9)] for y in range(9)]
        i = j = 0
        # j column
        # i row
        for ch in puzzlePlain:
            if ch != '.':
                board[j][i] = int(ch)

            i = i + 1
            if i >= 9:
                i = 0
                j = j + 1
        return board

    @staticmethod
    def printBoard(board):
        for j in range(9):
            for i in range(9):
                print(board[j][i], end=' ')
            print('')




if __name__ == '__main__':
    print(parser('../data/Sudoku.csv'))
    puzzlePlain = '625..1..8.7..8...68........2....4....4..1.3........1.......7.32.....6.9..84.3....'
    sudoku = SudokuCSP(puzzlePlain)
    sudoku.backtracingSearchStart()
